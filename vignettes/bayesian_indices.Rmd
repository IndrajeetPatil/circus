---
title: "Systematic Simulation of Bayesian Models"
output: 
  github_document:
    toc: true
    fig_width: 10.08
    fig_height: 6
  rmarkdown::html_vignette:
    toc: true
    fig_width: 10.08
    fig_height: 6
tags: [r, bayesian, posterior, test]
vignette: >
  \usepackage[utf8]{inputenc}
editor_options: 
  chunk_output_type: console
---



This code was used by the articles presented in [bayestestR](https://easystats.github.io/bayestestR/) to simulate statistical models.



# Functions


```{r eval=TRUE, message=FALSE, warning=FALSE, results='hide'}
library(tidyverse)
library(logspline)
library(bayestestR)
library(parameters)
library(see)
library(rstanarm)





# Convenience functions --------------------------------------------------------
# Generate data
generate_data <- function(true_effect=0, outcome_type="linear", sample_size=50, error=0){
  # Generate data
  data <- data.frame(x = sort(rnorm(sample_size, 0, 1)))
  if(outcome_type == "linear"){
     if(true_effect == 1){
      data$y <- data$x
    } else{
      data$y <- parameters::standardize(cos(data$x*5))
    }
  } else{
    if(true_effect == 1){
      data$y <- ifelse(data$x > 0, 1, 0)
    } else{
      data$y <- ifelse(cos(data$x*5) > 0, 1, 0)
    }
  }
  # Add error
  data$x <- parameters::standardize(data$x + rnorm(sample_size, 0, error))

  return(data)

}



# Compute model
compute_model <- function(data, outcome_type="linear", type=c("frequentist", "bayesian"), chains=4, iter=2000, warmup = 1/2){

  if("frequentist" %in% c(type)){
    if(outcome_type == "linear"){
      model_freq <- lm(y ~ x, data=data)
    } else{
      model_freq <- glm(y ~ x, data=data, family="binomial")
    }
    params <- parameters::model_parameters(model_freq)[2, ] %>%
        select(beta, SE, CI_low_95_freq = CI_low, CI_high_95_freq = CI_high, p_value = p)
  } else{
    params <- data.frame(beta = NA)
  }

  if("bayesian" %in% c(type)){
    if(outcome_type == "linear"){
      temp <- capture.output(
        model_bayes <- stan_glm(y ~ x, data=data, prior=normal(0, 1), chains=chains, iter=iter, warmup = round(warmup * iter)))
    } else{
      temp <- capture.output(
        model_bayes <- stan_glm(y ~ x, data=data, family="binomial", prior=normal(0, 1), chains=chains, iter=iter, warmup = round(warmup * iter)))
    }
    posterior <- as.data.frame(model_bayes)$x
    
    params$chains <- chains
    params$iterations <- iter
    params$warmup <- round(warmup * iter)
    params$samples <- nrow(posterior)
    
    params$Median <- median(posterior)
    params$Mean <- mean(posterior)
    map <- map_estimate(posterior)
    params$MAP <- map
    
    params$MAP_density <- attributes(map)$MAP_density
    params$p_direction_simple <- p_direction(posterior, method="simple")
    params$p_direction_AUC <- p_direction(posterior, method="AUC")
    params$p_MAP <- p_map(posterior)
    
    range <- rope_range(model_bayes)
    params$ROPE_range <- range[[2]]
    params$ROPE_90 <- rope(posterior, range = range, ci=0.90)$ROPE_Percentage
    params$ROPE_95 <- rope(posterior, range = range, ci=0.95)$ROPE_Percentage
    params$ROPE_full <- rope(posterior, range = range, ci=1)$ROPE_Percentage
    params$p_ROPE <- tryCatch({
    p_rope(posterior, range = range)
    }, error = function(error_condition) {
        NA
    })
    # Bayesfactor
    params$bayesfactor_cauchy07 <- as.numeric(bayesfactor_savagedickey(posterior, 
                                      prior = distribution_cauchy(length(posterior), location=0, scale=0.707), 
                                      hypothesis = 0))
    
    params$bayesfactor_cauchy1 <- as.numeric(bayesfactor_savagedickey(posterior, 
                                      prior = distribution_cauchy(length(posterior), location=0, scale=1), 
                                      hypothesis = 0))
    
    priors <- insight::get_priors(model_bayes)[2, ]
    params$bayesfactor_normal <- as.numeric(bayesfactor_savagedickey(posterior, 
                                  prior = distribution_normal(length(posterior), 0, priors$adjusted_scale), 
                                  hypothesis = 0))
    
    # CI
    ci_95 <- hdi(posterior, ci=0.95)
    params$CI_low_95_hdi <- ci_95$CI_low
    params$CI_high_95_hdi <- ci_95$CI_high
    
    ci_90 <- hdi(posterior, ci=0.90)
    params$CI_low_90_hdi <- ci_90$CI_low
    params$CI_high_90_hdi <- ci_90$CI_high
    
    ci_95 <- ci(posterior, ci=0.95)
    params$CI_low_95_quantile <- ci_95$CI_low
    params$CI_high_95_quantile <- ci_95$CI_high
    
    ci_90 <- ci(posterior, ci=0.90)
    params$CI_low_90_quantile <- ci_90$CI_low
    params$CI_high_90_quantile <- ci_90$CI_high
    
  }
  
  params
}



# Combine
generate_and_process <- function(true_effect, outcome_type, sample_size, error, type=c("frequentist", "bayesian"), chains=4, iter=2000, warmup = 1/2){
  
  data <- generate_data(true_effect=true_effect, outcome_type=outcome_type, sample_size=sample_size, error=error)
  params <- compute_model(data, outcome_type = outcome_type, type = type, chains=chains, iter=iter, warmup = warmup)
  
  rownames(params) <- NULL
  params
}
```




# Study 1 - Sample Size and Error


## Method



The simulation aimed at modulating the following characteristics:

- **Model type**: linear or logistic.
- **"True" effect** (original regression coefficient from which data is drawn): Can be 1 or 0 (no effect).
- **Sample size**: From 20 to 100 by steps of 10.
- **Error**: Gaussian noise applied to the predictor with SD uniformly spread between 0.33 and 6.66 (with 1000 different values).

We generated a dataset for each combination of these characteristics, resulting in a total of `2 * 2 * 9 * 1000 = 36000` Bayesian and frequentist models.


## Generation


```{r eval=FALSE, message=FALSE, warning=FALSE, results='hide'}
options(mc.cores = parallel::detectCores())
set.seed(333)

# Parameters -------------------------------------------------------------------
outcome_types <- c("binary", "linear")
effects <- c(0, 1)
sample_sizes <- seq(20, 100, length.out = 9)
errors <- seq(0.33, 6.66, length.out = 5)

# Run --------------------------------------------------------------------------
# Initialize data
all_data <- data.frame()

# Start loop
for(outcome_type in outcome_types){
  print(outcome_type)
  for(true_effect in effects){
    for(error in errors){
      for(sample_size in sample_sizes){
        for(iteration in 1:2){
          cat(".")
          
          fail <- TRUE
          while(fail==TRUE){
            params <- tryCatch({
              params <- generate_and_process(true_effect=true_effect, outcome_type=outcome_type, sample_size=sample_size, error=error)
              fail <- FALSE
            },error=function(e){
            },warning=function(w){
              cat("*")
            })
          }
   
          # Save data
          params <- mutate(params,
                             true_effect=true_effect,
                             sample_size=sample_size,
                             outcome_type = outcome_type,
                             error = error,
                             iteration=iteration)
          all_data <- rbind(all_data, params)
        }
      }
    }
  }
  write.csv(all_data, "bayesSim_study1.csv", row.names = FALSE)
}
```

```{r message=FALSE, warning=FALSE, include=FALSE, results='hide'}
# all_data <- read.csv("https://raw.github.com/easystats/circus/master/data/bayesSim_study1.csv")
```

## Visualise data

### Example data

```{r eval=TRUE, message=FALSE, warning=FALSE, fig.height=20, fig.width=16}
effects <- c(0, 1)
sample_sizes <- c(240)
outcome_types <- c("binary", "linear")
errors <- seq(0.33, 6.66, length.out = 3)

example_data <- data.frame()
for(outcome_type in outcome_types){
  for(true_effect in effects){
    for(error in errors){
      for(sample_size in sample_sizes){
        data <- generate_data(true_effect, outcome_type, sample_size, error)
        example_data <- rbind(
          example_data,
          mutate(data,
                 true_effect=true_effect,
                 outcome_type=outcome_type,
                 sample_size=sample_size,
                 error=error))
      }
    }
  }
}

linear_noeffect <- example_data %>% 
  filter(outcome_type == "linear",
         true_effect==0) %>% 
  mutate(sample_size = as.factor(sample_size),
         error = as.factor(error)) %>% 
  ggplot(aes(x=x, y=y, color=error)) +
  geom_point2(width=0.02, alpha=0.2, size=3) +
  geom_smooth(method="lm")+
  theme_modern() +
  scale_color_material_d() +
  facet_wrap(~error, scale="free", nrow=3)
linear_effect <- example_data %>% 
  filter(outcome_type == "linear",
         true_effect==1) %>% 
  mutate(sample_size = as.factor(sample_size),
         error = as.factor(error)) %>% 
  ggplot(aes(x=x, y=y, color=error)) +
  geom_point2(width=0.02, alpha=0.2, size=3) +
  geom_smooth(method="lm")+
  theme_modern() +
  scale_color_material_d() +
  facet_wrap(~error, scale="free", nrow=3)
binary_noeffect <- example_data %>% 
  filter(outcome_type == "binary",
         true_effect==0) %>% 
  mutate(true_effect = as.factor(true_effect),
         sample_size = as.factor(sample_size),
         error = as.factor(error)) %>% 
  ggplot(aes(x=x, y=y, color=error)) +
  geom_point2(width=0.02, alpha=0.2, size=3) +
  geom_smooth(method="glm")+
  theme_modern() +
  scale_color_material_d() +
  facet_wrap(~true_effect*error, scale="free", nrow=3)
binary_effect <- example_data %>% 
  filter(outcome_type == "binary",
         true_effect==1) %>% 
  mutate(true_effect = as.factor(true_effect),
         sample_size = as.factor(sample_size),
         error = as.factor(error)) %>% 
  ggplot(aes(x=x, y=y, color=error)) +
  geom_point2(width=0.02, alpha=0.2, size=3) +
  geom_smooth(method="glm")+
  theme_modern() +
  scale_color_material_d() +
  facet_wrap(~true_effect*error, scale="free", nrow=3)

plots(linear_effect, linear_noeffect, 
      binary_effect, binary_noeffect, 
      nrow = 2,
      tags=TRUE, tags_labels=c("Linear - Effect", "Linear - No effect",
                               "Binary - Effect", "Binary - No effect"))
```

### Observed Coefficients

```{r eval=TRUE, message=FALSE, warning=FALSE}
all_data %>%
  mutate(sample_size = as.factor(sample_size),
         beta = as.numeric(beta),
         true_effect = as.factor(true_effect)) %>% 
  ggplot(aes(x=true_effect, y=beta, fill=sample_size)) +
  geom_boxplot() +
  theme_modern() +
  scale_fill_material_d("rainbow") +
  xlab("Specified Coef") +
  ylab("Actual Coef") +
  facet_wrap(~outcome_type, scale="free_y")

all_data %>% 
  mutate(sample_size = as.factor(sample_size),
         beta = as.numeric(beta),
         error = as.numeric(error),
         true_effect = as.factor(true_effect)) %>% 
  ggplot(aes(x=error, y=beta, color=sample_size)) +
  geom_point2(alpha=0.01, size=3) +
  geom_smooth(se=FALSE)+
  theme_modern() +
  scale_color_material_d("rainbow") +
  xlab("Error") +
  ylab("Actual") +
  facet_wrap(~outcome_type*true_effect, scale="free")

all_data %>% 
  mutate(sample_size = as.factor(sample_size),
         true_effect = as.factor(true_effect),
         beta = as.numeric(beta)) %>% 
  ggplot(aes(x=beta, fill=sample_size)) +
  geom_density(alpha=0.1) +
  theme_modern() +
  scale_fill_material_d() +
  xlab("Actual Coef") +
  facet_wrap(~true_effect*outcome_type, scale="free")
```

# Study 2 - Priors Specification


The simulation aimed at modulating the following characteristics:

- **Model type**: linear or logistic.
<!-- - **"True" effect** (original regression coefficient from which data is drawn): Can be 1 or 0 (no effect). -->
- **prior direction**: either "congruent", "uninformative" (0) or "opposite" (-1).
- **prior precision**: prior SD from 0.5 to 1.5.


# Study 3 - Sampling Characteristics


## Method


The simulation aimed at modulating the following characteristics:

- **Model type**: linear or logistic.
- **"True" effect** (original regression coefficient from which data is drawn): Can be 1 or 0 (no effect).
- **chains**: from 1 to 8
- **iterations**: from 100 to 4000 by step of 100.
- **warmup**: Ratio of warmup iterations. from 1/10 to 9/10 by step of 0.1.

We generated 3 datasets for each combination of these characteristics, resulting in a total of `2 * 2 * 8 * 40 * 9 * 3 = 34560` Bayesian and frequentist models.


## Generation


```{r eval=FALSE, message=FALSE, warning=FALSE, results='hide'}
# options(mc.cores = parallel::detectCores())
set.seed(333)

# Parameters -------------------------------------------------------------------
outcome_types <- c("binary", "linear")
effects <- c(0, 1)
# chains <- seq(1, 8)
# iterations <- seq(100, 4000, by=100)
# warmups <- seq(1/10, 9/10, by=1/10)
chains <- seq(1, 2)
iterations <- seq(100, 1000, by=100)
warmups <- seq(3/10, 7/10, by=1/10)
# Run --------------------------------------------------------------------------
# Initialize data
all_data <- data.frame()

# Start loop
for(outcome_type in outcome_types){
  print(outcome_type)
  for(true_effect in effects){
    for(n_chains in chains){
      for(n_iterations in iterations){
        for(warmup in warmups){
          for(iteration in 1:2){
            cat(".")
            
            fail <- TRUE
            while(fail==TRUE){
              params <- tryCatch({
                params <- generate_and_process(true_effect=true_effect, outcome_type=outcome_type, sample_size=50, error=1, type="bayesian", iter=n_iterations, chains=n_chains, warmup=warmup)
                fail <- FALSE
                params
              },error=function(e){
              },warning=function(w){
                cat("*")
              })
            }
     
            # Save data
            params <- mutate(params,
                               true_effect=true_effect,
                               outcome_type = outcome_type,
                               iteration=iteration)
            all_data <- rbind(all_data, params)
          }
        }
      }
    }
  }
  write.csv(all_data, "bayesSim_study2.csv", row.names = FALSE)
}
```

```{r message=FALSE, warning=FALSE, include=FALSE, results='hide'}
# all_data <- read.csv("https://raw.github.com/easystats/circus/master/data/bayesSim_study2.csv")
```



# References
